load("@google_bazel_common//tools/maven:pom_file.bzl", "pom_file")

# This file is based on https://github.com/aj-michael/aar_with_jni which is
# subject to the following copyright and license:

# MIT License

# Copyright (c) 2019 Adam Michael

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# android_library's implicit aar doesn't flatten its transitive
# dependencies. When using the kotlin rules, the kt_android_library rule
# creates a few underlying libraries, because of this the classes.jar in
# the aar we built was empty. This rule separately builds the underlying
# kt.jar file, and replaces the aar's classes.jar with the kotlin jar
def aar_with_jni(name, android_library, manifest, archive_name, native_deps = [], proguard_rules = "", visibility = []):
    manifest_name = name + "_android_manifest"
    android_binary_name = name + "_bin"
    jni_archive_name = archive_name + "_jni"
    pom_name = name + "_pom"
    cc_lib_name = name + "_jni_interface_lib"

    # This is for the pom xml. It has a public visibility since this can be accessed in the root BUILD file
    pom_file(
        name = pom_name,
        targets = [android_library],
        template_file = "//bazel:pom_template.xml",
        visibility = visibility,
    )

    # Create a dummy manifest file for our android_binary
    native.genrule(
        name = archive_name + "_binary_manifest_generator",
        outs = [archive_name + "_generated_AndroidManifest.xml"],
        cmd = """
cat > $(OUTS) <<EOF
<manifest
  xmlns:android="http://schemas.android.com/apk/res/android"
  package="does.not.matter">
  <uses-sdk android:minSdkVersion="999"/>
</manifest>
EOF
""",
    )

    # We wrap our native so dependencies in a cc_library because android_binaries
    # require a library target as dependencies in order to generate the appropriate
    # architectures in the directory `lib/`
    native.cc_library(
        name = cc_lib_name,
        srcs = native_deps,
    )

    # This outputs {jni_archive_name}_unsigned.apk which will contain the base files for our aar
    native.android_binary(
        name = jni_archive_name,
        manifest = archive_name + "_generated_AndroidManifest.xml",
        custom_package = "does.not.matter",
        srcs = [],
        deps = [android_library, cc_lib_name],
    )

    # This creates bazel-bin/library/kotlin/src/io/envoyproxy/envoymobile/name_bin_deploy.jar
    # This jar has all the classes needed for our aar and will be our `classes.jar`
    native.android_binary(
        name = android_binary_name,
        manifest = manifest,
        srcs = [],
        deps = [android_library],
    )

    # This is to generate the envoy mobile aar AndroidManifest.xml
    native.genrule(
        name = manifest_name,
        outs = [manifest_name + ".xml"],
        cmd = """
cat > $(OUTS) <<EOF
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="io.envoyproxy.envoymobile" >

    <application>
    </application>

</manifest>
EOF
""",
    )

    # This gen rule does the following:
    # 1. Unzips the apk file generated by the `jni_archive_name` into a temporary directory
    # 2. Renames the `lib` directory to `jni` directory since the aar requires the so files
    #    to be in the `jni` directory
    # 3. Copy the android binary `jar` output from the `android_binary_name` as `classes.jar`
    # 4. Copy the proguard rules specified in the macro parameters
    # 5. Override the apk's aar with a generated one
    # 6. Zip everything in the temporary directory into the output
    native.genrule(
        name = name,
        srcs = [
            android_binary_name + "_deploy.jar",
            jni_archive_name + "_unsigned.apk",
            manifest_name + ".xml",
            pom_name + ".xml",
            proguard_rules,
        ],
        outs = [
            archive_name + ".aar",
        ],
        visibility = visibility,
        cmd = """
orig_dir=$$PWD
classes_dir=$$(mktemp -d)
echo "Creating classes.jar from {jar}"
cd $$classes_dir
unzip $$orig_dir/$(location {jar}) "io/envoyproxy/*" "META-INF/" > /dev/null
zip -r classes.jar * > /dev/null
cd $$orig_dir
echo "Constructing aar..."
final_dir=$$(mktemp -d)
cp $$classes_dir/classes.jar $$final_dir
cd $$final_dir
unzip $$orig_dir/$(location {jni_apk}) lib/ > /dev/null
mv lib jni
cp $$orig_dir/$(location {proguard_rules}) ./proguard.txt
cp $$orig_dir/$(location {manifest}) AndroidManifest.xml
zip -r tmp.aar * > /dev/null
cp tmp.aar $$orig_dir/$@
""".format(
            manifest = manifest_name + ".xml",
            jar = android_binary_name + "_deploy.jar",
            jni_apk = jni_archive_name + "_unsigned.apk",
            proguard_rules = proguard_rules,
        ),
    )
